Written in: Python

The user is first prompted on if they would like to have all the steps of the process printed out for them before asking which type of matrix would they like to tet (each matrix type is seperated by a folder, there is a seperate folder that contains all the matrices to be tested all at once).

Going through each file in the folder, the AI tracks the objects inside both the matrix and the answer choices and rebuilds the matrix for its own knowledge. The properties that are tracked as part of the pattern are: Object ID, Shape, Color, Size, and X/Y position inside the cell. A cell is the row and column position inside of the matrix.

From here it proceeds with an adapted version of version spaces. For each row it tracks the specific patterns found for the Shape, Color, and Size properties (3 specific patterns for each row). For example, in the first row for the shape property it be "Square, Square, Circle" (each comma indicating another column). Once the specific pattern is found for each row, it will then find general patterns that work accross the matrix based on the specific patterns for each property. Using the specific pattern from the example as before the general pattern found would be "A, A, B"

Now with a general pattern to build off of, it creates 3 hypothesis trees consiting of the general patterns (one for each property used for the patterns) with each level in the tree being a how many variables can be changed at the time (for level 0, 0 variables are changed; level 1, 1 variable is changed, etc.). For each level it will try all possible combinations of that property, applying each combination to the matrix to see if it works for each row. If it does it will add that to the appropriate level. As an example, in level 0 it would try the pattern "A, A, B" accross the matrix. Then in level 1 it would change 1 variable at a time, first changing A so it would try "Square, Square, B" then "Circle, Circle, B" etc. then doing the same for B. On level 2 it will then try every possible combination as well ("Square, Square, Circle"; "Square, Square, Triangle" .... "Hexagon, Hexagon, Star").

Lastly, with all the trees now built, it will go through each answer choice and create a temporary row is created conisiting of the last row of the matrix with the answer choice being plugged into the last cell. From each hypothesis tree, it apply the most specific pattern in them (being 3 specific-general patterns total as their are 3 properties we are looking for). If all 3 patterns can be applied to the row then it assumes that choice as the correct answer. It then compares its choice to the actual to see if it is actually correct. If it is wrong, it will make note of it to tell the user at the end before moving on to the next file and repeating the process.

Once every file is read, it will then tell the user how many were correct, how many were wrong, and which files were wrong along with the choice it made compared to the correct choice.
